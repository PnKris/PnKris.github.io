---
layout: post
title: Call的执行流程分析 未完待续中
categories: [Android, okhttp]
tags: [okhttp]
catalog: true
date: 2018-12-20
---

由于入职新公司，加班较多也有点不太适应，所以这篇文章拖的时间有点长，sorry啦~~~

### 前言
上一篇文章分析了一下Request类的内部的结构，这一篇文章开始分析Call类，及RealCall的相关源码。

### newCall()

我们在使用OkHttp发起请求的时候，有一步就是OkHttpClient根据Request对象调用newCall()创建一个Call对象。
```java
Call call = okHttpClient.newCall(request);
```

#### OkHttpClient.newCall()分析
```java
    @Override 
    public Call newCall(Request request) {
        return new RealCall(this, request);
    }
```
这里面直接new了一个RealCall。

### RealCall 类分析

#### 成员变量
- OkHttpClient client;

我们在前面调用new RealCall()的时候将okHttpClient传入进来了

- RetryAndFollowUpInterceptor retryAndFollowUpInterceptor

重定向及重试拦截器

- boolean executed

判断当前request是否已经执行

- Request originalRequest

由于我们会对request进行一些重定向或者添加一些auth信息操作，所以用一次变量保存最原始的request请求

#### AsyncCall内部类
对于所有的异步请求，我们在enqueue()方法中都会创建一个AsyncCall对象发起请求，AsyncCall是一个Runnable的实现类，最终会放到DisPatcher中的线程池中进行执行。


#### 核心方法
- execute()
同步请求方法，调用Dispatcher的executed()方法直接在当前线程中执行请求 

- enqueue()
异步请求方法,调用Dispatcher的enqueue()方法直接在当前线程中执行请求 

- getResponseWithInterceptorChain()
创建一个完整的拦截器链，将我们在构造OkHttpClient对象的时候，传入进来的interceptor，以及内部的几个interceptor组合到一起，形成一个拦截器链。


### 执行流程
在分析整个执行流程之前，我们来看一个非常重要的类Dispatcher，这个在做OkHttpClient分析的时候提到过。我们先看一下里面的成员变量。

#### Dispatcher分析

```java
  private int maxRequests = 64;
  private int maxRequestsPerHost = 5;
  private Runnable idleCallback;

  /** Executes calls. Created lazily. */
  private ExecutorService executorService;

  /** Ready async calls in the order they'll be run. */
  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();

  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();

  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();

```
##### 重要的成员变量分析
- maxRequests 

同时执行的最大异步请求数，在okHttp里面，通过这个参数，保证了同时执行的异步请求数最大只能是64。当然，我们也可以通过在构造okHttpClient的时候，传入一个自己new出来的Dispatcher，然后设置这个最大值。

对于同步来说，由于在同一个线程中同步请求是顺序的执行的，所以不需要进行控制。后面会在分析execute()执行流程时会讲到。

- maxRequestsPerHost

同一个host，同时执行的最大请求数，跟maxRequests有点类似，但是这个值是针对同一个host来说的。向同一个host发起请求时，okhttp里面限制同时请求的数量。目的就是考虑到后台服务器的压力。

- executorService

线程池，异步请求都是在线程池中进行的。


- readyAsyncCalls

等待处理的异步请求队列。当正在执行异步请求的数量大于maxRequests(默认为64)，或者同一个host的正在执行的异步请求数量大于maxRequestsPerHost(默认为5)时，就会将后续的异步请求放到这里。

- runningAsyncCalls

正在处理的异步请求的队列

- runningSyncCalls
同步请求的列队，所有的同步请求都是存放在这个队列里面


#### 同步请求流程
```java
Call call = okHttpClient.newCall(request);
call.execute();
```
上文分析了newCall()中，直接返回了一个RealCall对象，RealCall是Call接口得一个实现类。
那么call.execute()实际上就是realCall的execute()方法：
```java
  @Override public Response execute() throws IOException {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already Executed");
      executed = true;
    }
    try {
      client.dispatcher().executed(this);
      Response result = getResponseWithInterceptorChain();
      if (result == null) throw new IOException("Canceled");
      return result;
    } finally {
      client.dispatcher().finished(this);
    }
  }
```
- if (executed) 

判断是否执行过， 这里是在同步代码块中判断的，线程安全

- client.dispatcher().executed(this);

通过Dispatcher来将realCall放到同步请求队列runningSyncCalls中。这个队列是同步请求队列，所有的同步请求都会丢到这里来处理。
看一下代码：
```java
synchronized void executed(RealCall call) {
    runningSyncCalls.add(call);
}
```
这里注意一下，只是将realCall添加到runningSyncCalls中，记住这里，下一步执行同步请求。

- Response result = getResponseWithInterceptorChain();

这里调用了一个拦截器链，通过拦截器链的层层处理，最终会将服务器对于请求的响应结果返回过来，后面会专门写一篇拦截器链的工作原理来讲解这一块的内容，这里我们只需要知道这么调用就能得到服务器的响应。

这里的result会在finally执行完以后才会返回。（注意：java的知识点，finally会在return之前执行）

通过getResponseWithInterceptorChain()执行完请求，那么我们需要将这个realcall从runningSyncCalls中移除，那么这里怎么移除的，一起看下一步调用的Dispatcher.finish()

- client.dispatcher().finished(this);

由于请求过程中可能会抛出一些异常，无论是否正确执行这个请求，我们都会执行finish()这个方法，将请求从队列中删除，保证我们后续的请求能够顺利进行。
看一下代码：
```java
void finished(RealCall call) {
    finished(runningSyncCalls, call, false);
}

private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
    int runningCallsCount;
    Runnable idleCallback;
    synchronized (this) {
      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
      if (promoteCalls) promoteCalls();
      runningCallsCount = runningCallsCount();
      idleCallback = this.idleCallback;
    }

    if (runningCallsCount == 0 && idleCallback != null) {
      idleCallback.run();
    }
  }
```
我们主要看第二个finish()方法：
- synchronized (this) 

由于Dispatcher中的几个队列都是非线程安全的，所以呢，这里加了个同步机制。

- if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");

这里是移除队列的第一个realCall,并且判断是不是能正确移除

- if (promoteCalls) promoteCalls(); 

由于promoteCalls的值为false，所以此处不执行。promoteCalls()的作用是调整两个异步请求队列（runningAsyncCalls和readyAsyncCalls）中的AsyncCall的，我们后面再说。

- runningCallsCount = runningCallsCount();

计算所有的正在执行的请求数，包括同步和异步的请求

- if (runningCallsCount == 0 && idleCallback != null) {
      idleCallback.run();
    }

这里什么意思呢，其实就是一个回调，告诉我们，这个okhttpClient中已经没有请求在执行了，就这么简单，一般开发中我还没遇到过要用这个东西的。

同步请求的分发流程小结：

- 将realCall添加到runningSyncCalls队列中
- 调用realCall自身的getResponseWithInterceptorChain()得到服务器响应信息
- 调用Dispatcher.finish()，将这个realCall从队列中移除。
- 最后将result返回


未完待续中... 明天或者后天晚上更新异步请求流程






